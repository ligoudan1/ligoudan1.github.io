<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正则校验大全(持续更新)]]></title>
    <url>%2F2019%2F09%2F11%2F%E6%AD%A3%E5%88%99%E6%A0%A1%E9%AA%8C%E5%A4%A7%E5%85%A8-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[正则校验大全1.表情校验1let reg = /(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff])&#123;2&#125;|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/g 2.金额数字1234567/** * 金额数字 * @param &#123;*&#125; s */export function isMoney (s) &#123; return /(^[1-9]([0-9]+)?(\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\.[0-9]([0-9])?$)/.test(s) &amp;&amp; s !== 0&#125; 3.身份证号码1234567/** * 身份证号码 * @param &#123;*&#125; s */export function isIdcard (s) &#123; return /(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/.test(s)&#125; 4.url地址1234567/** * URL地址 * @param &#123;*&#125; s */export function isURL (s) &#123; return /^http[s]?:\/\/.*/.test(s)&#125; 5.电话号码1234567/** * 电话号码 * @param &#123;*&#125; s */export function isPhone (s) &#123; return /^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/.test(s)&#125; 6.手机号码1234567/** * 手机号码 * @param &#123;*&#125; s */export function isMobile (s) &#123; return /^1[0-9]&#123;10&#125;$/.test(s)&#125; 7.邮箱1234567/** * 邮箱 * @param &#123;*&#125; s */export function isEmail (s) &#123; return /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/.test(s)&#125;]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端css代码规范]]></title>
    <url>%2F2019%2F09%2F02%2F%E5%89%8D%E7%AB%AFcss%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[1、命名规则说明 1、所有的命名最好都小写 2、属性的值一定要用双引号(&quot;&quot;)括起来，且一定要有值如class=&quot;app&quot;,id=&quot;app&quot; 3、每个标签都要有开始和结束，且要有正确的层次，排版有规律工整例如：&lt;div&gt;&lt;/div&gt; 4、空元素要有结束的tag或于开始的tag后加上”/“ &lt;br /&gt;、&lt;img /&gt; 5、表现与结构完全分离，代码中不涉及任何的表现元素，如style、font、bgColor、border等 6、&lt;h1&gt;到&lt;h6&gt;的定义，应遵循从大到小的原则，体现文档的结构，并有利于搜索引擎的查询,因此，请不要利用标题标签来改变同一行中的字体大小。相反，我们应当使用层叠样式表定义来达到漂亮的显示效果。 7、给每一个表格和表单加上一个唯一的、结构标记id 8、给图片加上alt标签,alt属性是一个必需的属性，它规定在图像无法显示时的替代文本。假设由于下列原因用户无法查看图像，alt 属性可以为图像提供替代的信息：网速太慢、src 属性中的错误、浏览器禁用图像、用户使用的是屏幕阅读器。 9、尽量使用英文命名原则 10、尽量不缩写，除非一看就明白的单词如btn。 11、命名方式(BEM)：类-体（例：g-head）、类-体-修饰符（例：u-btn-active）。 12、scss中的变量、函数、混合、placeholder采用驼峰式命名 13、后代选择器：体-修饰符即可（例：.m-page .cut{}）注：后代选择器不要在页面布局中使用，因为污染的可能性较大； 14、减少id命名，id在JS是唯一的，不能多次使用，id的优先级优先与class，所以id应该按需使用，而不能滥用。 2、网页外层重要部分CSS样式命名 wrap —————— 用于最外层 header —————- 用于头部 main —————— 用于主体内容（中部） main-left ————- 左侧布局 main-right ———— 右侧布局 nav ——————- 网页菜单导航条 content ————— 用于网页中部主体 footer —————- 用于底部 3、样式属性顺序 1、定位：position z-index left right top bottom clip等。 2、自身属性：width height min-height max-height min-width max-width等。 3、文字样式：color font-size letter-spacing, color text-align等。 4、背景：background-image border等。 5、文本属性: text-align vertical-align text-wrap text-transform text-indent text-decoration letter-spacing word-spacing white-space text-overflow等。 6、css3中属性：content、box-shadow、animation、border-radius、transform等 123456789/* yes */ /* no */.example &#123; .example &#123; z-index: -1; color: red; display: inline-block; background-color: #eee; font-size: 16px; display: inline-block; color: red; z-index: -1; background-color: #eee; font-size: 16px;&#125; &#125;复制代码 目的：减少浏览器reflow(回流)，提升浏览器渲染dom的性能。]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端开荒之数组中好用的方法(一)]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E8%8D%92%E4%B9%8B%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A5%BD%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[数组中好用的方法1.find​ find为arr数组调用的方法,接受一个callback返回函数,而arr.find()返回的是经过callback函数符合函数条件的第一个值 ​ 需要注意的是:在callback开始执行的时候,再去操作arr数组的值,此时并不会改变callback的执行,callback执行的依旧是原数组的值 ​ 例如: 12345var arr=[1,2,3];var arr2 =arr,find(function(e) &#123; return e &gt;2&#125;);arr.push(4) 此时在callback已经执行,然后再去push,是不会按照push执行的 find的高级用法​ 我们可以利用find方法来寻找一个较为复杂的数组 ​ 例如: 123456789var arr=[ &#123;id:1, name:"xxx", age:15&#125;, &#123;id:99, name:"zzz", age:14&#125;, ...] 当然,我现在只写了两条,实际情况下成百上千条都有可能,这时候比如我们要找 id=99的数组的一项的name是什么 此时便可以调用find方法 我在这里定义一个find方法的函数 1const findName = (arr,value) =&gt; arr,find(obj =&gt; obj.id=value).name 这个findName函数接受两个参数,第一个参数arr表示要查询的数组,第二个参数表示要查询的id的值,根据这个函数,则可以找到对应id的name 当然,也可以使用for循环来找对应的值 123456var id=99for (var i =0;i&lt;arr.length;i++) &#123; if(arr[i].id = id ) &#123; return arr[i].name &#125;&#125; 这样进行大量的for循环找到的也是想同的值,然后找到之后进行return操作 当然,我们也可以使用forEach来操作数组 12345arr.forEach(item =&gt; &#123; if(item.id==99) &#123; console.log(item.item.name) &#125;&#125;) 这样也可以接收到id为99的数组那项的值 但是forEach有个很麻烦的地方,他会遍历整个数组的值,不会说遇到就停止,使用break和return都不会将其打断,这样是比较耗费性能的 然而,就没有办法打断了吗? 借用《JavaScript权威指南（6版）》7.9.1 forEach() 一句话 注意，forEach（）无法在所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach（）方法放在一个try块中，并能抛出一个异常。如果forEach（）调用的函数抛出foreach.break异常，循环会提前终止 ​ 代码如下 1234567891011121314try &#123; arr.forEach(item =&gt; &#123; if(item.id==99) &#123; console.log(item.item.name) foreach.break=new Error("StopIteration") &#125; &#125;)&#125;catch(e) &#123; console.log(e.message); if(e.message==="foreach is not defined") &#123; console.log("跳出来了?"); return; &#125;else throw e;&#125;]]></content>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue踩坑之渲染对象]]></title>
    <url>%2F2019%2F08%2F01%2Fvue%2F</url>
    <content type="text"><![CDATA[vue踩坑之渲染对象1.问题最近在工作中遇到这这样的问题,要讲一个对象的一条属性使用差值语法展示出来 html代码如下: 123&lt;div class="hello"&gt; &lt;h1&gt;&#123;&#123;msg.name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 一个很普通的代码片段,需要展示出来, 现在在data里面传入这个对象 12345data () &#123; return &#123; msg:&#123;&#125; &#125;&#125; 传入这个msg后,需要在vue的生命周期函数中发送ajax请求获取数据,并让获取到的msg替代data中的msg,此处,我直接替换 123mounted() &#123; this.msg.name="222"&#125; 我在mounted中替换了msg的值,然后我打开了页面,差值语法中的msg.name并没有刷新出来 2.分析问题遇到问题后首先分析,这进行视图更新,并没有触发视图更新,然而log后的msg确实是存在name属性 首先查看vue的官方文档,对于这方面的描述 官方文档中有这样的一段话 “当vue的data里边声明或者已经赋值过的对象或者数组（数组里边的值是对象）时，向对象中添加新的属性，如果更新此属性的值，是不会更新视图的。” 这段话已经说得很明确了,我们也是这样做的 我们在data里面声明了msg对象,然后在生命周期函数中往msg对象添加了新属性name 所以造成了vue的视图未更新 3.解决问题既然官方文档已经说的很明确,如果往对象中添加新的属性,如果更新此属性的值,是不会更新视图的 那么,我们首先可以将msg的name在data中定义 即: 1234567data () &#123; return &#123; msg:&#123; name:"" &#125; &#125;&#125; 那么我们已经拥有了name属性,在下面更新name属性,也会造成vue的视图层更新 那么,如果我们不想在msg中添加name属性呢? vue中也提供了对应的方法,即在vue实例中有一个$set方法 即: 123mounted() &#123; this.$set(this.msg,"name","222")&#125; this.$set要传入三个值,第一个值为要修改的对象/数组,第二个值为要修改的属性,第三个值为要修改的内容 这样也可以触发vue的视图更新 遇到问题不要怕,要学会分析问题并解决问题]]></content>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需求踩坑之动态渲染大量数据表格]]></title>
    <url>%2F2019%2F07%2F22%2F%E9%9C%80%E6%B1%82%E8%B8%A9%E5%9D%91%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[需求踩坑之动态获取数据表格1.需求最近拿到了这样一个需求 要求是这样的: 1.渲染一个表格,要求表头为1-30的数字排序 2.获取后台传过来的一个长度不固定的字符串 3.将这个字符串2个绑定为一小组,分别填入到这个表格的tbody中 4.当填入的数据为30个时,即要换行在下一行展示 例如: 效果图: 后台接受的数据: 2.实施一开始使用的element-ui 1234567891011121314151617181920&lt;template&gt; &lt;el-table :data="tableData" style="width: 100%"&gt; &lt;el-table-column prop="date" label="日期" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt;&lt;/template&gt; 上面这个是element-ui的官方文档中的代码 需要传入一个tableData的数组, 代码为: 1234567891011121314151617181920212223export default &#123; data() &#123; return &#123; tableData: [&#123; date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄' &#125;, &#123; date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' &#125;, &#123; date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' &#125;] &#125; &#125;&#125; 这怎么传???? 先开始做吧 首先使用v-for生成30个表头 1234567&lt;el-table-column :prop="'msg'+item" :label="String(item)" v-for="(item, index) in 30" :key="index" width="45"&gt;&lt;/el-table-column&gt; emmm,够狠,直接循环30个表头,因为label这里只能接受string类型的参数(虽然传入number类型的能用,但是会报错,这个和vuex中的直接修改stroe中的值一样) 反正效果已经实现了,继续下一个步骤 因为这个tabledata对应的是一个对象数组,所以要循环生成对象 对象的属性怎么循环生成??? ??? 又一次陷入了迷茫 这里我走了一次岔路 既然不能循环生成,那么我自己手写 123456789101112131415161718192021222324252627282930313233var that=this;var itemobj = &#123; msg1: "", msg2: "", msg3: "", msg4: "", msg5: "", msg6: "", msg7: "", msg8: "", msg9: "", msg10: "", msg11: "", msg12: "", msg13: "", msg14: "", msg15: "", msg16: "", msg17: "", msg18: "", msg19: "", msg20: "", msg21: "", msg22: "", msg23: "", msg24: "", msg25: "", msg26: "", msg27: "", msg28: "", msg29: "", msg30: ""&#125;; 先不管如何,效果实现就ok 然后对数据进行转换 要创建的行为要接受的数据/30/2 30为一列的个数,2为每个单元格展示两个数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var strlength = msg.length;// 需要创建多少列var listNum = Math.ceil(strlength / 30 / 2);console.log(listNum);// 将拿到的数据两个一组拼成一个30位的数组// 控制字符串每两位加一个,function insertEnter(str, n) &#123; var len = str.length; var strTemp = ""; if (len &gt; n) &#123; strTemp = str.substring(0, n); str = str.substring(n, len); return strTemp + "," + insertEnter(str, n); &#125; else &#123; return str; &#125;&#125;// 使字符串转为数组var allMsgList = insertEnter(msg, 2).split(",");console.log(allMsgList);// 创建表数据console.log(itemobj);console.log();for (let i = 0; i &lt; listNum; i++) &#123; that.tableData.push(itemobj);&#125;console.log(that.tableData);// 让字符串数组的每一项去找到对应的数据// 拆分多个数组function sliceArray(array, size) &#123; var result = []; for (var x = 0; x &lt; Math.ceil(array.length / size); x++) &#123; var start = x * size; var end = start + size; result.push(array.slice(start, end)); &#125; return result;&#125;var groupedArray = sliceArray(allMsgList, 30); 经过这一系列操作后 得到的groupedArray的值为 ok,这就是想要的,那么怎么填充上去呢? ??? 再写一次循环? 在这里我卡住了 既然element-ui不能实现的功能,那么用原生来写 这时候我拿到的数据为上图所示,展示的话就需要循环创建接受的数据/30/2的行 然后在每一行中循环生成每一个列 1234567891011121314&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th v-for="(item, index) in 30" :key="index"&gt;&#123;&#123;item&#125;&#125;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="(alllist, index) in allMsgList" :key="index"&gt; &lt;td&gt;&lt;/td&gt; &lt;td v-for="(item, index) in alllist" :key="index"&gt;&#123;&#123;item&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 经过两次循环,然后得到了最上面的需求结果 3.总结这个需求最主要的就是用需要大量的数据的交互 需要动态实时的将其展示在上面,所以逻辑不能太复杂 如果我继续手写循环生成的话,可能我接受到了数据开始渲染,上一条数据还没有渲染完成 所以最开始就应该从简单,确保数据的稳定传输入手]]></content>
      <tags>
        <tag>需求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket原理及应用]]></title>
    <url>%2F2019%2F07%2F12%2Fwebsocket%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[websocket深入理解1.websocket原理websocket原理在之前的博客中生动形象的描述过了,这里大概介绍一下 百度对于websocket的解释是:WebSocket是一种在单个TCP连接上进行全双工通信的协议 也就是说websocket是基于TCP协议可以进行双向通信的一个工具 并且websocket在建立服务器和客户端直接的连接的时候只需要完成一次握手,即可实现双向通信,不像发送ajax协议需要实现三次握手四次挥手,并且websocket的实时性,和控制开销,更好的连接状态的保持都是优于ajax websocket的诞生是人们为了解决实时推送技术,因为之前全是使用的ajax轮询,也就是使用ajax技术在特定的时间内发送http请求,然后服务器返回数据给客户端的浏览器,这样的效率其实很慢,因为ajax发送出去的http请求可能含有较长的头部,然而真正有效的数据可能仅仅是后面那一部分,所以浪费了服务器带宽,而且比较新一点的技术做轮询的是Comet,这种技术实现了双向通信,但是依然是含有较长的头部,浪费带宽 2.websocketAPI补充补充一点,websocket使用的是http的101状态码建立连接,如下图: 再补充一点,部分浏览器可能不支持websocket接口,你可以在浏览器中尝试实例,目前现代主流浏览器都支持websocket: Chrome, Mozilla, Opera 和 Safari API1.创建一个websocket实例12// 打开一个 web socketvar ws = new WebSocket("ws://后端提供的websocket地址"); 2.开启websocket并发送数据给后端地址123456ws.onopen = function()&#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send("发送数据"); alert("数据发送中...");&#125;; onopen方法为打开websocket连接,其中ws为上面创建的websocket的实例 send方法为发送数据的方法,其中本次发送字符串”发送数据”内容 3.通过websocket接受后端发送过来的数据12345ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert("数据已接收...");&#125;; 之前也说过,websocket为双向通信,有发即有收 onmessage函数为接受数据,在函数中可传入evt行参来接受数据 4.websocket关闭函数为什么要说websocket关闭函数?因为只有在触发websocket关闭的时候才会触发的函数(是不是有点废话了) 为什么这么说呢?关闭可能存在很多种情况,后端关闭,前端关闭,通信关闭都会触发 12345ws.onclose = function()&#123; // 关闭 websocket alert("连接已关闭..."); &#125;; 5.自测浏览器是否支持websocket这个应该在开始说的,一般现代浏览器都支持websocket,在MDN上面也有兼容图,我就直接贴在这里了 当然你也可以用代码的形式来检验你的浏览器是否支持websocket 123456if ("WebSocket" in window) &#123; alert("您的浏览器支持 WebSocket!"); &#125;else &#123; alert("您的浏览器不支持 WebSocket!") &#125; 当然,你也可以看出来,如果说浏览器支持websocket,即浏览器window对象中含有websocket对象 3.简单的websocket测试你可以用以下代码来进行websocket的自测 可以打开调试工具来监听websocket 注意:此代码的自测网站会将你发送的websocket请求全部以websocket形式发送给你,所以,发送我写了循环9999次,所以接受也会有9999条数据打印到控制台 直接贴代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;websocket测试&lt;/title&gt; &lt;div id="message"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; function WebSocketTest() &#123; if ("WebSocket" in window) &#123; alert("您的浏览器支持 WebSocket!"); // 打开一个 web socket var ws = new WebSocket("ws://echo.websocket.org"); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 for (let index = 0; index &lt; 9999; index++) &#123; ws.send("发送数据"+index); &#125; alert("数据发送中..."); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; // document.getElementById('message').innerHTML += received_msg + '&lt;br/&gt;'; console.log(evt); // alert("数据已接收..."); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert("连接已关闭..."); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert("您的浏览器不支持 WebSocket!"); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="sse"&gt; &lt;a href="javascript:WebSocketTest()"&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 4.websocket进阶简单的websocket已经完成,但是在实际工作中,我们使用websocket需要考虑到多方面应用 以下,借用公司大佬写的websocket封装的文件,来做详细讲解 1.与后台数据约定,加密传输发送数据前,需要在websocket中传入后台指定的参数并且加密传输 例如: 12345678910111213141516171819202122232425262728//websocketconst tio = &#123;&#125;tio.ws = &#123;&#125;;/** * &#123; ws_protocol wss or ws , ip, port, paramStr,加在ws url后面的请求参数，形如：name=张三&amp;id=12 heartbeatTimeout,心跳时间 单位：毫秒 reconnInterval,重连间隔时间 单位：毫秒 binaryType 'blob' or 'arraybuffer';//arraybuffer是字节 handler 处理器 &#125; */tio.ws = function(&#123; ws_protocol = 'ws', // 发送协议 ip = '192.168.1.10', // ip port = '9326', // 端口号 heartbeatTimeout = 5000, // 心跳时间 reconnInterval = 1000, // 重连间隔 binaryType = 'blob', // 数据格式 paramStr, // 携带传过来的参数 handler&#125;) &#123;....&#125; 在此函数中,给定了函数默认值,并且paramStr为前端携带过来的参数 前端vue页面也封装了一个函数: 12345678910111213141516171819202122232425262728293031323334353637initIM() &#123; var that = this; var nonce = randomNum(1, 10000), signTimestamp = new Date().getTime(); // 创建随机数字字符串 var signature = sha1("XXXX" + nonce + signTimestamp); // 加密算法 that.tiows = new that.$tio.ws(&#123; paramStr: &#123; appKey: "XXXX", nonce: nonce, signTimestamp: signTimestamp, signature: signature, userId: that.loginUser.id, groups: "", identity: "service" &#125;, handler: &#123; onopen: function(event, ws) &#123;&#125;, onclose: function(event, ws) &#123;&#125;, onerror: function(event, ws) &#123;&#125;, ping: function(ws) &#123; ws.send(JSON.stringify(&#123; chatType: "heartbeat" &#125;)); // 心跳开始发送 &#125;, onmessage: function(data, ws) &#123; that.loading = false; console.log("接收消息", data); // 成功接收数据后,给表格注入数据 // 将接收到的数据存储至store中,实现数据共享 that.$store.commit('common/updataMymsg',data.data) for (let i = 0; i &lt; that.tableData.length; i++) &#123; that.tableData[i].address = data.data; &#125; &#125; &#125; &#125;); that.tiows.connect();&#125;, 与后端约定的数据(这里我用XXXX代替,不是appkey)与signTimestamp和nonce后进行加密,然后传输给后台通过验证,后台再将验证完的数据处理再返回新的数据给我 2.传输数据之前,需要将数据进行处理因为我们是通过websocket形式,以url地址将数据发送过去,即在封装的websocket方法中需要将其方法进行处理 12345678910111213141516171819202122232425262728 this.ip = ip this.port = port this.url = ws_protocol + '://' + ip + ':' + port // 拼接url字符串 this.binaryType = binaryType if (paramStr) &#123; this.url = addUrlParam(this.url, paramStr) this.reconnUrl = this.url + "&amp;" &#125; else &#123; this.reconnUrl = this.url + "?" &#125; this.reconnUrl += "reconnect=true"; var addUrlParam = function(url = '', params = &#123;&#125;) &#123; if (url &amp;&amp; JSON.stringify(params) != "&#123;&#125;") &#123; var paramArray = []; Object.keys(params).forEach(function(key) &#123; var param = key + '=' + params[key] paramArray.push(param) &#125;); var url2 = encodeURI(url + '?' + paramArray.join('&amp;')); var enurl = encodeURI(url2); return enurl &#125; else &#123; return url; &#125;&#125; 上面代码执行操作了后将数据从url上面扒下来提取成为键值对的形式 3.设置websocket心跳,确保数据的实时性为了确保数据的实时性和准确性,需要在websocket上面增加心跳 确保websocket在一定的时间内没收到信息再重新发送请求 123456789101112this.handler = handler this.heartbeatTimeout = heartbeatTimeout this.reconnInterval = reconnInterval this.lastInteractionTime = function() &#123; if (arguments.length == 1) &#123; this.lastInteractionTimeValue = arguments[0] &#125; return this.lastInteractionTimeValue &#125; this.heartbeatSendInterval = heartbeatTimeout / 2 上面的代码规定了心跳发送时间,而真正的发送心跳的时间将在websocket发送数据时执行 4.使用websock发送数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071this.connect = function(isReconnect) &#123; var _url = this.url; if (isReconnect) &#123; _url = this.reconnUrl; &#125; try &#123; var ws = new WebSocket(_url); this.ws = ws &#125; catch (err) &#123; console.log("错误", err) &#125; ws.binaryType = this.binaryType; // 'arraybuffer'; // 'blob' or 'arraybuffer';//arraybuffer是字节 var self = this ws.onopen = function(event) &#123; self.handler.onopen.call(self.handler, event, ws) self.lastInteractionTime(new Date().getTime()) self.pingIntervalId = setInterval(function() &#123; self.ping(self) &#125;, self.heartbeatSendInterval) // 开启ws并设置心跳时间 &#125; ws.onmessage = function(event) &#123; if (event.data) &#123; var data = JSON.parse(event.data) console.log(data); if (data.code != 200) &#123; self.handler.onmessage.call(self.handler, data, ws) &#125; if (data.code == 401) &#123; clearInterval(self.pingIntervalId) &#125; &#125; self.lastInteractionTime(new Date().getTime()) &#125; ws.onclose = function(event) &#123; clearInterval(self.pingIntervalId) // clear send heartbeat task try &#123; self.handler.onclose.call(self.handler, event, ws) &#125; catch (error) &#123;&#125; //self.reconn(event) &#125; ws.onerror = function(event) &#123; clearInterval(self.pingIntervalId) self.handler.onerror.call(self.handler, event, ws) &#125; return ws &#125; this.reconn = function(event) &#123; var self = this setTimeout(function() &#123; var ws = self.connect(true) self.ws = ws &#125;, self.reconnInterval) &#125; this.ping = function() &#123; var iv = new Date().getTime() - this.lastInteractionTime(); // 已经多久没发消息了 // 单位：秒 if ((this.heartbeatSendInterval + iv) &gt;= this.heartbeatTimeout) &#123; this.handler.ping(this.ws) &#125; &#125;; this.send = function(data) &#123; this.ws.send(data); &#125;;&#125; 这样,封装的一个websocket的方法就完成了,确保了数据传输的安全性和稳定性,虽然官方文档介绍websocket很粗略,但是数据传输确实需要考虑到很多方面 欢迎关注我的微信公众号一起学习前端知识 5.参考文档 HTML5websocket|菜鸟教程 MDN|websocketAPI websockt自测网站|websocket.org]]></content>
      <tags>
        <tag>web前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui踩坑]]></title>
    <url>%2F2019%2F07%2F08%2Felement-ui%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[element-ui踩坑1.使用websocket给前端vuex中传值并将vuex中的值实时渲染到页面表格在element-ui中提供的表格样式中,默认以:data=&quot;tableData&quot;的形式传入表格数据,其中tableData在vue中以data函数的方式return出来,例如: 123456789101112131415161718192021data() &#123; return &#123; tableData: [&#123; date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄' &#125;, &#123; date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' &#125;, &#123; date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' &#125;] &#125;&#125; 现在要接受vuex中动态传入的值,则需要将vuex中值写入computed和watch中作为监听使用,例如: 12345678910111213computed: &#123; listmsg() &#123; return this.$store.state.user.msg; &#125;&#125;,watch: &#123; listmsg(val, oldval) &#123; this.tableData[0].address = oldval[0]; this.tableData[1].address = oldval[1]; this.tableData[2].address = oldval[2]; this.tableData[3].address = oldval[3]; &#125;&#125; 如上,computed中接受了vuex中的msg值 注意:此处vuex写了模块user,所以要在state中拿值必须从this.$store.state.user拿值 然后用拿到的值,在watch中监听值得改变,进行实时的渲染 2.使用element-ui中的表格斑马纹,边框由于在element-ui中使用表格元素会有默认的hover事件(放上去会变色) 在这里可以看到,表格第一项触发了hover事件(鼠标截图时在第一行上面放着) 为了给表格添加斑马纹 在element-ui的官方文档中也给出了详细的说明: stripe属性可以创建带斑马纹的表格。它接受一个Boolean，默认为false，设置为true即为启用。 边框也是一样的 在element-ui中给表格添加边框: 默认情况下，Table 组件是不具有竖直方向的边框的，如果需要，可以使用border属性，它接受一个Boolean，设置为true即可启用。 3.使用element-ui中的带状态表格栏在使用element-ui中的带状态表格栏的时候,我觉得和斑马纹,边框对比起来应该是一样的,没有什么难度,然后我就根据官方文档将代码C+V进我的代码 官方文档: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;el-table :data="tableData" style="width: 100%" :row-class-name="tableRowClassName"&gt; &lt;el-table-column prop="date" label="日期" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt;&lt;/template&gt;&lt;style&gt; .el-table .warning-row &#123; background: oldlace; &#125; .el-table .success-row &#123; background: #f0f9eb; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; methods: &#123; tableRowClassName(&#123;row, rowIndex&#125;) &#123; if (rowIndex === 1) &#123; return 'warning-row'; &#125; else if (rowIndex === 3) &#123; return 'success-row'; &#125; return ''; &#125; &#125;, data() &#123; return &#123; tableData: [&#123; date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄', &#125;, &#123; date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄', &#125;, &#123; date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;] &#125; &#125; &#125;&lt;/script&gt; 在methods中需要把逻辑写好 然而在使用了带状态表格栏后没有效果 谷歌的调试工具也没有报错 在网上找了一大圈后,找到解决方案: 1.去除style中的scoped因为在element-ui中row-class-name、row-style、cell-class-name等属性要想生效必须使用全局class才能生效。因为之前的代码都是在组件中编写的，所以去除&lt;style scoped&gt;&lt;/style&gt;中的scoped即可该组件中的样式变为全局属性。 2.去除斑马纹属性在element-ui中,斑马纹属性与带状态表格栏属性冲突 即把stripe属性修改为flase,或者直接在表格标签中删除stripe 即最后的的以websocket发送数据获取到的数据动态展现在vue搭建的前端框架的element-ui的表格中的代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;template&gt; &lt;div&gt; &lt;el-table :data="tableData" style="width: 100%" border v-loading="loading" :row-class-name="tableRowClassName" &gt; &lt;el-table-column prop="date" label="日期" width="180"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;router-link to="/"&gt;第一组数据&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapActions &#125; from "vuex"; // 引入vuex中各个模块的actionsimport &#123; mapState &#125; from "vuex";export default &#123; data() &#123; return &#123; tableData: [ &#123; date: "2016-05-02", name: "王小虎", address: "数据处理中" &#125;, &#123; date: "2016-05-04", name: "王小虎", address: "数据处理中" &#125;, &#123; date: "2016-05-01", name: "王小虎", address: "数据处理中" &#125;, &#123; date: "2016-05-03", name: "王小虎", address: "数据处理中" &#125; ], loading: true &#125;; &#125;, methods: &#123; ...mapActions(&#123; getmsg: "getmsg" &#125;), tableRowClassName(&#123;row, rowIndex&#125;) &#123; if (rowIndex === 1 &amp;&amp; this.tableData[1].address== "数据处理中") &#123; return 'warning-row'; &#125; else if (rowIndex === 3) &#123; return 'success-row'; &#125; return ''; &#125; &#125;, computed: &#123; listmsg() &#123; return this.$store.state.user.msg; &#125; &#125;, watch: &#123; listmsg(val, oldval) &#123; this.tableData[0].address = oldval[0]; this.tableData[1].address = oldval[1]; this.tableData[2].address = oldval[2]; this.tableData[3].address = oldval[3]; this.loading = false; &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;.el-table .warning-row &#123; background: rgb(236, 145, 145);&#125;.el-table .success-row &#123; background: #f0f9eb;&#125;&lt;/style&gt; 数据为模拟数据,第四行变色为官方文档自带变色,第二行变色为我写的文档变色,我在此表格中加入了loading组件,意为数据尚未加载时先不触发 完整表格效果图如下]]></content>
      <categories>
        <category>element-ui</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>web前端技术</tag>
        <tag>ui框架</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这几天工作中websocket踩坑]]></title>
    <url>%2F2019%2F07%2F05%2F%E8%BF%99%E5%87%A0%E5%A4%A9%E5%B7%A5%E4%BD%9C%E4%B8%ADwebsocket%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1.websocket的资料整合菜鸟教程关于websocket的比较官方的文档说明,适合新手查看,并且里面配有测试环境(python) websocket.org有关于websocket的测试和一些具体说明页面 2.看完了解websocket原理(转载)1.websocket与httpWebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算） 首先HTTP有 1.1 和 1.0 之说，也就是所谓的 keep-alive ，把多个HTTP请求合并为一个，但是 Websocket 其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解 有交集，但是并不是全部。 另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。。通俗来说，你可以用HTTP协议传输非Html数据，就是这样=。= 再简单来说，层级不一样。 2.Websocket是什么样的协议，具体有什么优点首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。 HTTP的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次HTTP请求就结束了。 在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request = Response， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。 教练，你BB了这么多，跟Websocket有什么关系呢？_(:з」∠)_好吧，我正准备说Websocket呢。。 首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。 首先我们来看个典型的 Websocket 握手（借用Wikipedia的。。） 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: &quot;http://example.com&quot; 熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。我会顺便讲解下作用。 Upgrade: websocketConnection: Upgrade这个就是Websocket的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。 123Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠窝，我要验证尼是不是真的是Websocket助理。 然后， Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~ 最后， Sec-WebSocket-Version 是告诉服务器所使用的 Websocket Draft （协议版本），在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦大家都使用的一个东西 脱水： 服务员，我要的是13岁的噢→_→ 然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！ 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~ 12Upgrade: websocketConnection: Upgrade 依然是固定的，告诉客户端即将升级的是 Websocket 协议，而不是mozillasocket，lurnarsocket或者shitsocket。 然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。 服务器：好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。 后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。 至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。具体的协议就不在这阐述了。 ——————技术解析部分完毕—————— 你TMD又BBB了这么久，那到底Websocket有什么鬼用， http long poll ，或者ajax轮询 不都可以实现实时信息传递么。 好好好，年轻人，那我们来讲一讲Websocket有什么用。来给你吃点胡（苏）萝（丹）卜（红） 3.Websocket的作用在讲Websocket之前，我就顺带着讲下 long poll 和 ajax轮询 的原理。 ajax轮询ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。 场景再现： 客户端：啦啦啦，有没有新信息(Request) 服务端：没有（Response） 客户端：啦啦啦，有没有新信息(Request) 服务端：没有。。（Response） 客户端：啦啦啦，有没有新信息(Request) 服务端：你好烦啊，没有啊。。（Response） 客户端：啦啦啦，有没有新消息（Request） 服务端：好啦好啦，有啦给你。（Response） 客户端：啦啦啦，有没有新消息（Request） 服务端：。。。。。没。。。。没。。。没有（Response） —- loop long polllong poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。 场景再现： 客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） 服务端：额。。 等待到有消息的时候。。来 给你（Response） 客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop 从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。 何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。 简单地说就是，服务器是一个很懒的冰箱（这是个梗）（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。 说完这个，我们再来说一说上面的缺陷（原谅我废话这么多吧OAQ） 从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。 ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小） 所以 ajax轮询 和 long poll 都有可能发生这种情况。 客户端：啦啦啦啦，有新信息么？ 服务端：月线正忙，请稍后再试（503 Server Unavailable） 客户端：。。。。好吧，啦啦啦，有新信息么？ 服务端：月线正忙，请稍后再试（503 Server Unavailable） 客户端：然后服务端在一旁忙的要死：冰箱，我要更多的冰箱！更多。。更多。。（我错了。。这又是梗。。） 言归正传，我们来说Websocket吧通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。 一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。 哦对了，忘记说了HTTP还是一个状态协议。 通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。 所以在这种情况下出现了，Websocket出现了。他解决了HTTP的这几个难题。首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。所以上面的情景可以做如下修改。 客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request） 服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched） 客户端：麻烦你有信息的时候推送给我噢。。 服务端：ok，有的时候会告诉你的。 服务端：balabalabalabala 服务端：balabalabalabala 服务端：哈哈哈哈哈啊哈哈哈哈 服务端：笑死我了哈哈哈哈哈哈哈 就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你 ） 这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。那么为什么他会解决服务器上消耗资源的问题呢？ 其实我们所用的程序是要经过两层代理的，即HTTP协议在Nginx等服务器的解析下，然后再传送给相应的Handler（PHP等）来处理。简单地说，我们有一个非常快速的 接线员（Nginx） ，他负责把问题转交给相应的 客服（Handler） 。 本身接线员基本上速度是足够的，但是每次都卡在客服（Handler）了，老有客服处理速度太慢。，导致客服不够。Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持久连接，有信息的时候客服想办法通知接线员，然后接线员在统一转交给客户。 这样就可以解决客服处理速度过慢的问题了。 同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输 identity info （鉴别信息），来告诉服务端你是谁。 虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的处理时间，而且还会在网路传输中消耗过多的流量/时间。 但是Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。 同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了 ——————– 至于怎么在不支持Websocket的客户端上使用Websocket。。答案是： 不能 但是可以通过上面说的 long poll 和 ajax 轮询 来 模拟出类似的效果内容转自知乎：http://www.zhihu.com/question/20215561]]></content>
      <categories>
        <category>web前端技术</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端Web开发资源整理]]></title>
    <url>%2F2019%2F07%2F04%2F%E5%89%8D%E7%AB%AFWeb%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1）想开发项目，哪里找教程？ 2）关于前端的有趣网站 一、前端项目哪里找？ 前端的入门教程网上很多，只要你搜索呼啦啦就出来了，因此啊，就不整理了。主要整理一下，哪里可以找到前端项目，就是有源代码的，可以拿来学习或者拿来用的。 没有详细的教程，但可以找到项目并查看源代码和效果图：1、CodePen 网站里有很多很酷的特效，而且看到它们的源代码，也可以看到效果图。 其实类似的网站有很多，就不一一介绍了： [RunJS](https://link.zhihu.com/?target=http%3A//runjs.cn/square) [CSSdeck](https://link.zhihu.com/?target=http%3A//cssdeck.com/) 2、 [CodePlayer](https://link.zhihu.com/?target=http%3A//thecodeplayer.com/) 网站里有各种项目效果，选择自己想学的，同样可以看到源代码和效果图，和codepen不同的是你可以看到作者是怎样把代码打出来的。 3、html5tricks 网站里有很多前端实现的功能，可以在线查看效果，也可以下载源码的。 有详细的教程，而且步骤详细，教你一步步开发出项目：4、phodal/ideabook 一个练手项目集，有很多实战项目，有步骤、效果图，同样可以看到源代码啊。 5、实验楼-WEB网站里有很多前端项目教程，可以跟着教程一步步在环境中实现，并查看效果图，同样可以下载源代码，非常适合项目实战学习。 二、前端有趣的网站： 1、JS1k大名鼎鼎的js1K，1K字节以内的Javascript代码，实现一个酷炫的动画、特效、小游戏之类的。官网从2010年开始征集参赛作品，现在已经办了７年了，还在办。 2、Can I useCAN I USE，相信每个前端同学都不陌生，查询浏览器兼容性的利器。 3、JSHint一个在线JS检测工具，可以检测JavaScript代码中的错误和潜在问题。 4、aaencode将JS代码转换成常用的网络表情，例如“(ﾟΘﾟ)”。转换的代码并不复杂，可以在源代码里看到。 类似的还有： jsobfuscate一个在线混淆工具，通过先进的算法，来混淆你的JavaScript代码，使其不可读。该工具还可以减小文件的大小，以便快速加载。 5、Best CSS Button Generator网站主要提供各种按钮的CSS代码，你可以从预设的按钮中选择并使用模板用于自己的设计，还可以查看源代码，非常适合学习。 还有一个类似的： Enjoy CSS 网站是一个完整的代码生成器，可以自定义输入域或CSS3按钮，同样可以查看源代码，适合学习。 6、CSS属性指引 一份清单，按字母表顺序列出了每个CSS属性。 7、frontendrescue 里面分享了网络上关于前端的各种资源、大牛等信息，总之很多资源就对了。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端资源</tag>
      </tags>
  </entry>
</search>
